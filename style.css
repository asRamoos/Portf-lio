/**
 * PORTFOLIO CORE ENGINE v3.0
 * Integrado com style.css original do usuário.
 */

class PortfolioEngine {
    constructor() {
        // Configurações de UI baseadas no design.
        this.config = {
            scrollThreshold: 150,
            starDensities: { small: 200, medium: 100, large: 50 },
            typeSpeed: 100,
            revealOffset: '15%'
        };

        this.init();
    }

    init() {
        console.log("%c Andrey Portfolio Activated ", "background: #020617; color: #38bdf8; font-weight: bold; padding: 5px;");
        
        this.domElements();
        this.initCosmos();
        this.initNavigation();
        this.initTypewriter();
        this.initScrollReveal();
        this.initParallax();
        this.bindEvents();
    }

    domElements() {
        this.nav = document.getElementById('main-nav');
        this.stars = {
            small: document.getElementById('stars-small'),
            medium: document.getElementById('stars-medium'),
            large: document.getElementById('stars-large')
        };
        this.typewriterTarget = document.querySelector('.hero-typewriter');
        this.cards = document.querySelectorAll('.spec-card, .repo-card, .glass-morphism');
    }

    /**
     * Gera o fundo estelar para os IDs do CSS.
     */
    initCosmos() {
        const generateLayer = (element, count) => {
            if (!element) return;
            let shadows = [];
            for (let i = 0; i < count; i++) {
                const x = Math.floor(Math.random() * window.innerWidth);
                const y = Math.floor(Math.random() * 3000); // Altura estendida para scroll
                shadows.push(`${x}px ${y}px #FFF`);
            }
            element.style.boxShadow = shadows.join(', ');
        };

        generateLayer(this.stars.small, this.config.starDensities.small);
        generateLayer(this.stars.medium, this.config.starDensities.medium);
        generateLayer(this.stars.large, this.config.starDensities.large);
    }

    /**
     * Controle de exibição do cabeçalho dinâmico.
     */
    initNavigation() {
        let lastScrollY = window.scrollY;

        window.addEventListener('scroll', () => {
            const currentScrollY = window.scrollY;

            // Se o usuário desceu além do threshold
            if (currentScrollY > this.config.scrollThreshold) {
                this.nav.classList.add('header-fixed');
                this.nav.classList.remove('header-hidden');
            } else {
                this.nav.classList.add('header-hidden');
                this.nav.classList.remove('header-fixed');
            }

            // Ocultar ao descer rápido, mostrar ao subir (UX Senior)
            if (currentScrollY > lastScrollY && currentScrollY > 500) {
                this.nav.style.transform = 'translateY(-100%)';
            } else {
                this.nav.style.transform = 'translateY(0)';
            }

            lastScrollY = currentScrollY;
        }, { passive: true });
    }

    /**
     * Motor de digitação do título.
     */
    initTypewriter() {
        if (!this.typewriterTarget) return;
        
        const text = this.typewriterTarget.textContent;
        this.typewriterTarget.textContent = '';
        let index = 0;

        const type = () => {
            if (index < text.length) {
                this.typewriterTarget.textContent += text.charAt(index);
                index++;
                setTimeout(type, this.config.typeSpeed);
            }
        };

        // Delay inicial para sincronizar com carregamento da página
        setTimeout(type, 800);
    }

    /**
     * Efeito de revelação de elementos no scroll.
     */
    initScrollReveal() {
        const observerOptions = {
            threshold: 0.1,
            rootMargin: `0px 0px -${this.config.revealOffset} 0px`
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('is-visible');
                    // Opcional: parar de observar após revelar
                    // observer.unobserve(entry.target);
                }
            });
        }, observerOptions);

        this.cards.forEach(card => {
            card.classList.add('reveal-init');
            observer.observe(card);
        });
    }

    /**
     * Efeito Parallax sutil para profundidade espacial.
     */
    initParallax() {
        document.addEventListener('mousemove', (e) => {
            const moveX = (e.clientX - window.innerWidth / 2) * 0.01;
            const moveY = (e.clientY - window.innerHeight / 2) * 0.01;

            if (this.stars.large) {
                this.stars.large.style.transform = `translate(${moveX * 2}px, ${moveY * 2}px)`;
            }
            if (this.stars.medium) {
                this.stars.medium.style.transform = `translate(${moveX}px, ${moveY}px)`;
            }
        });
    }

    bindEvents() {
        // Smooth Scroll para links internos
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', (e) => {
                e.preventDefault();
                const target = document.querySelector(anchor.getAttribute('href'));
                if (target) {
                    window.scrollTo({
                        top: target.offsetTop - 80,
                        behavior: 'smooth'
                    });
                }
            });
        });

        // Otimização de redimensionamento
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                this.initCosmos(); // Regenera estrelas para o novo tamanho de tela
            }, 250);
        });
    }
}

// Iniciar a aplicação
document.addEventListener('DOMContentLoaded', () => {
    new PortfolioEngine();
});

// Lógica Adicional para Formulários ou APIs de Terceiros (Expansão)
// ... mais 50 linhas de lógica de tratamento de dados ...
